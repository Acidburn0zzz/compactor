/*
 * Copyright 2016-2017 Internet Corporation for Assigned Names and Numbers.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, you can obtain one at https://mozilla.org/MPL/2.0/.
 */

/*
 * Developed by Sinodun IT (www.sinodun.com)
 */

#include <chrono>
#include <sstream>
#include <vector>

#include "bytestring.hpp"
#include "catch.hpp"
#include "configuration.hpp"
#include "matcher.hpp"
#include "packetstatistics.hpp"

#include "packetstream.hpp"

SCENARIO("PacketStream correctly parses packet", "[parse]")
{
    Configuration config;
    std::vector<std::unique_ptr<DNSMessage>> dns_msgs;
    std::vector<std::shared_ptr<AddressEvent>> addr_events;
    PacketStream::DNSSink dns_sink =
        [&](std::unique_ptr<DNSMessage>& dns)
        {
            dns_msgs.push_back(std::move(dns));
        };
    PacketStream::AddressEventSink address_event_sink =
        [&](std::shared_ptr<AddressEvent> ae)
        {
            addr_events.push_back(ae);
        };

    PacketStream pkt_stream(config, dns_sink, address_event_sink);

    GIVEN("A sample raw query DNS message")
    {
        const uint8_t msg_raw[] =
            { 0x60,0xEB,0x69,0x8F,0x3C,0xB4,0x00,0x21,
              0x59,0x00,0xCF,0xF0,0x86,0xDD,0x60,0x00,
              0x00,0x00,0x00,0x3A,0x11,0x3B,0x20,0x01,
              0x05,0x78,0x00,0x03,0x11,0x01,0x00,0x00,
              0x00,0x00,0x00,0xBF,0x00,0x02,0x20,0x01,
              0x05,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
              0x00,0x00,0x00,0x00,0x00,0x42,0xB5,0x2A,
              0x00,0x35,0x00,0x3A,0xE7,0xEC,0x0F,0x93,
              0x00,0x10,0x00,0x01,0x00,0x00,0x00,0x00,
              0x00,0x01,0x08,0x72,0x69,0x39,0x35,0x6E,
              0x73,0x30,0x31,0x08,0x77,0x6B,0x67,0x6C,
              0x6F,0x62,0x61,0x6C,0x03,0x6E,0x65,0x74,
              0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x29,
              0x10,0x00,0x00,0x00,0x80,0x00,0x00,0x00 };
        Tins::Packet pkt(Tins::EthernetII(msg_raw, sizeof(msg_raw)),
                         std::chrono::microseconds(2000000));

        THEN("Packet is interpreted correctly")
        {
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            pkt_stream.process_packet(pcap);
            std::string expected =
                "1970-01-01 00h00m02s0us UTC:\n"
                "\tClient IP: 2001:578:3:1101::bf:2\n"
                "\tServer IP: 2001:500:3::42\n"
                "\tTransport: UDP\n"
                "\tClient port: 46378\n"
                "\tServer port: 53\n"
                "\tHop limit: 59\n"
                "\tDNS QR: Query\n"
                "\tID: 3987\n"
                "\tOpcode: 0\n"
                "\tRcode: 0\n"
                "\tFlags: CD \n"
                "\tQdCount: 1\n"
                "\tAnCount: 0\n"
                "\tNsCount: 0\n"
                "\tArCount: 1\n"
                "\tName: ri95ns01.wkglobal.net\n"
                "\tType: 1\n"
                "\tClass: 1\n";

            REQUIRE(dns_msgs.size() == 1);
            std::ostringstream oss;
            oss << *(dns_msgs[0]);
            REQUIRE(oss.str() == expected);
        }
    }

    GIVEN("A fragmented IPv4 query")
    {
        const uint8_t msg_raw[] =
            { 0x54,0x9f,0x35,0x22,0xee,0x42,0x84,0xb8,
              0x02,0x7d,0x57,0xed,0x08,0x00,
              // IP header.
              0x45,0x00,0x00,0x3c,0xf2,0x66,0x20,0x00,
              0x3d,0x11,0x70,0x5a,0xa8,0xeb,0x57,0xc9,
              0xc7,0x07,0x53,0x2a,
              // IP body
              0x08,0xcb,0x00,0x35,0x00,0x32,0x00,0xc2,
              0x80,0x00,0x00,0x10,0x00,0x01,0x00,0x00,
              0x00,0x00,0x00,0x01,0x03,0x6e,0x73,0x34,
              0x05,0x61,0x70,0x6e,0x69,0x63,0x03,0x63,
              0x6f,0x6d,0x00,0x00,0x01,0x00,0x01,0x00, };
        const uint8_t msg2_raw[] =
            { 0x54,0x9f,0x35,0x22,0xee,0x42,0x84,0xb8,
              0x02,0x7d,0x57,0xed,0x08,0x00,
              // IP header.
              0x45,0x00,0x00,0x1e,0xf2,0x66,0x00,0x05,
              0x3d,0x11,0x70,0x5a,0xa8,0xeb,0x57,0xc9,
              0xc7,0x07,0x53,0x2a,
              // IP body
              0x00,0x29,0x10,0x00,0x00,0x00,0x80,0x00,
              0x00,0x00 };
        Tins::Packet pkt(Tins::EthernetII(msg_raw, sizeof(msg_raw)),
                         std::chrono::microseconds(2000000));
        Tins::Packet pkt2(Tins::EthernetII(msg2_raw, sizeof(msg2_raw)),
                         std::chrono::microseconds(2000020));

        THEN("First packet is ignored, second generates output")
        {
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            std::shared_ptr<PcapItem> pcap2 = std::make_shared<PcapItem>(pkt2);
            std::string expected =
                "1970-01-01 00h00m02s20us UTC:\n"
                "\tClient IP: 168.235.87.201\n"
                "\tServer IP: 199.7.83.42\n"
                "\tTransport: UDP\n"
                "\tClient port: 2251\n"
                "\tServer port: 53\n"
                "\tHop limit: 61\n"
                "\tDNS QR: Query\n"
                "\tID: 32768\n"
                "\tOpcode: 0\n"
                "\tRcode: 0\n"
                "\tFlags: CD \n"
                "\tQdCount: 1\n"
                "\tAnCount: 0\n"
                "\tNsCount: 0\n"
                "\tArCount: 1\n"
                "\tName: ns4.apnic.com\n"
                "\tType: 1\n"
                "\tClass: 1\n";

            pkt_stream.process_packet(pcap);
            REQUIRE(dns_msgs.size() == 0);
            pkt_stream.process_packet(pcap2);
            REQUIRE(dns_msgs.size() == 1);
            std::ostringstream oss;
            oss << *(dns_msgs[0]);
            REQUIRE(oss.str() == expected);
        }
    }

    GIVEN("A TCP query")
    {
        const uint8_t syn_raw[] =
            { 0x9c,0x97,0x26,0x94,0x39,0xc2,0x60,0x57,
              0x18,0x07,0x30,0x0a,0x08,0x00,0x45,0x00,
              0x00,0x3c,0x0e,0xd9,0x40,0x00,0x40,0x06,
              0xa7,0x47,0xc0,0xa8,0x01,0x4d,0xc0,0xa8,
              0x01,0xfe,0xec,0x23,0x00,0x35,0x5c,0x9d,
              0x54,0x13,0x00,0x00,0x00,0x00,0xa0,0x02,
              0x72,0x10,0x59,0x42,0x00,0x00,0x02,0x04,
              0x05,0xb4,0x04,0x02,0x08,0x0a,0x00,0x3e,
              0x5a,0xca,0x00,0x00,0x00,0x00,0x01,0x03,
              0x03,0x07 };
        const uint8_t synack_raw[] =
            { 0x60,0x57,0x18,0x07,0x30,0x0a,0x9c,0x97,
              0x26,0x94,0x39,0xc2,0x08,0x00,0x45,0x00,
              0x00,0x3c,0x7c,0x28,0x00,0x00,0x40,0x06,
              0x79,0xf8,0xc0,0xa8,0x01,0xfe,0xc0,0xa8,
              0x01,0x4d,0x00,0x35,0xec,0x23,0x3c,0x0c,
              0x0b,0xba,0x5c,0x9d,0x54,0x14,0xa0,0x12,
              0x10,0x00,0x54,0xdb,0x00,0x00,0x02,0x04,
              0x05,0xb4,0x01,0x03,0x03,0x00,0x01,0x01,
              0x08,0x0a,0x00,0xb2,0x20,0xf6,0x00,0x3e,
              0x5a,0xca };
        const uint8_t ack_raw[] =
            { 0x9c,0x97,0x26,0x94,0x39,0xc2,0x60,0x57,
              0x18,0x07,0x30,0x0a,0x08,0x00,0x45,0x00,
              0x00,0x34,0x0e,0xda,0x40,0x00,0x40,0x06,
              0xa7,0x4e,0xc0,0xa8,0x01,0x4d,0xc0,0xa8,
              0x01,0xfe,0xec,0x23,0x00,0x35,0x5c,0x9d,
              0x54,0x14,0x3c,0x0c,0x0b,0xbb,0x80,0x10,
              0x00,0xe5,0x8f,0xb9,0x00,0x00,0x01,0x01,
              0x08,0x0a,0x00,0x3e,0x5a,0xcb,0x00,0xb2,
              0x20,0xf6 };
        const uint8_t query_raw[] =
            { 0x9c,0x97,0x26,0x94,0x39,0xc2,0x60,0x57,
              0x18,0x07,0x30,0x0a,0x08,0x00,0x45,0x00,
              0x00,0x63,0x0e,0xdb,0x40,0x00,0x40,0x06,
              0xa7,0x1e,0xc0,0xa8,0x01,0x4d,0xc0,0xa8,
              0x01,0xfe,0xec,0x23,0x00,0x35,0x5c,0x9d,
              0x54,0x14,0x3c,0x0c,0x0b,0xbb,0x80,0x18,
              0x00,0xe5,0xdd,0x75,0x00,0x00,0x01,0x01,
              0x08,0x0a,0x00,0x3e,0x5a,0xcb,0x00,0xb2,
              0x20,0xf6,0x00,0x2d,0x4b,0x2e,0x01,0x20,
              0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,
              0x03,0x77,0x77,0x77,0x05,0x6c,0x75,0x6e,
              0x63,0x68,0x03,0x6f,0x72,0x67,0x02,0x75,
              0x6b,0x00,0x00,0x01,0x00,0x01,0x00,0x00,
              0x29,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
              0x00 };
        const uint8_t query_ack_raw[] =
            { 0x60,0x57,0x18,0x07,0x30,0x0a,0x9c,0x97,
              0x26,0x94,0x39,0xc2,0x08,0x00,0x45,0x00,
              0x00,0x34,0x7c,0x2f,0x00,0x00,0x40,0x06,
              0x79,0xf9,0xc0,0xa8,0x01,0xfe,0xc0,0xa8,
              0x01,0x4d,0x00,0x35,0xec,0x23,0x3c,0x0c,
              0x0b,0xbb,0x5c,0x9d,0x54,0x43,0x80,0x10,
              0x10,0x00,0x80,0x6f,0x00,0x00,0x01,0x01,
              0x08,0x0a,0x00,0xb2,0x20,0xf6,0x00,0x3e,
              0x5a,0xcb };
        const uint8_t response_raw[] =
            { 0x60,0x57,0x18,0x07,0x30,0x0a,0x9c,0x97,
              0x26,0x94,0x39,0xc2,0x08,0x00,0x45,0x00,
              0x00,0xfd,0x7c,0x30,0x00,0x00,0x40,0x06,
              0x79,0x2f,0xc0,0xa8,0x01,0xfe,0xc0,0xa8,
              0x01,0x4d,0x00,0x35,0xec,0x23,0x3c,0x0c,
              0x0b,0xbb,0x5c,0x9d,0x54,0x43,0x80,0x18,
              0x10,0x00,0x89,0xd0,0x00,0x00,0x01,0x01,
              0x08,0x0a,0x00,0xb2,0x20,0xf7,0x00,0x3e,
              0x5a,0xcb,0x00,0xc7,0x4b,0x2e,0x81,0x80,
              0x00,0x01,0x00,0x02,0x00,0x05,0x00,0x01,
              0x03,0x77,0x77,0x77,0x05,0x6c,0x75,0x6e,
              0x63,0x68,0x03,0x6f,0x72,0x67,0x02,0x75,
              0x6b,0x00,0x00,0x01,0x00,0x01,0xc0,0x0c,
              0x00,0x05,0x00,0x01,0x00,0x00,0x0e,0x10,
              0x00,0x0d,0x0a,0x70,0x69,0x67,0x77,0x69,
              0x64,0x67,0x65,0x6f,0x6e,0xc0,0x10,0xc0,
              0x2e,0x00,0x01,0x00,0x01,0x00,0x00,0x00,
              0x78,0x00,0x04,0xd5,0x8a,0x65,0x89,0xc0,
              0x10,0x00,0x02,0x00,0x01,0x00,0x00,0x8d,
              0xd7,0x00,0x10,0x04,0x64,0x6e,0x73,0x34,
              0x05,0x6d,0x74,0x67,0x73,0x79,0x03,0x63,
              0x6f,0x6d,0x00,0xc0,0x10,0x00,0x02,0x00,
              0x01,0x00,0x00,0x8d,0xd7,0x00,0x10,0x04,
              0x64,0x6e,0x73,0x31,0x05,0x6d,0x74,0x67,
              0x73,0x79,0x02,0x63,0x6f,0xc0,0x1a,0xc0,
              0x10,0x00,0x02,0x00,0x01,0x00,0x00,0x8d,
              0xd7,0x00,0x07,0x04,0x64,0x6e,0x73,0x33,
              0xc0,0x5c,0xc0,0x10,0x00,0x02,0x00,0x01,
              0x00,0x00,0x8d,0xd7,0x00,0x07,0x04,0x64,
              0x6e,0x73,0x32,0xc0,0x78,0xc0,0x10,0x00,
              0x02,0x00,0x01,0x00,0x00,0x8d,0xd7,0x00,
              0x07,0x04,0x64,0x6e,0x73,0x30,0xc0,0x78,
              0x00,0x00,0x29,0x10,0x00,0x00,0x00,0x00,
              0x00,0x00,0x00 };
        const uint8_t response_ack_raw[] =
            { 0x9c,0x97,0x26,0x94,0x39,0xc2,0x60,0x57,
              0x18,0x07,0x30,0x0a,0x08,0x00,0x45,0x00,
              0x00,0x34,0x0e,0xdc,0x40,0x00,0x40,0x06,
              0xa7,0x4c,0xc0,0xa8,0x01,0x4d,0xc0,0xa8,
              0x01,0xfe,0xec,0x23,0x00,0x35,0x5c,0x9d,
              0x54,0x43,0x3c,0x0c,0x0c,0x84,0x80,0x10,
              0x00,0xed,0x8e,0x83,0x00,0x00,0x01,0x01,
              0x08,0x0a,0x00,0x3e,0x5b,0x00,0x00,0xb2,
              0x20,0xf7 };

        Tins::Packet syn(Tins::EthernetII(syn_raw, sizeof(syn_raw)),
                         std::chrono::microseconds(2000000));
        Tins::Packet synack(Tins::EthernetII(synack_raw, sizeof(synack_raw)),
                            std::chrono::microseconds(2000020));
        Tins::Packet ack(Tins::EthernetII(ack_raw, sizeof(ack_raw)),
                         std::chrono::microseconds(2000040));
        Tins::Packet query(Tins::EthernetII(query_raw, sizeof(query_raw)),
                           std::chrono::microseconds(2000060));
        Tins::Packet query_ack(Tins::EthernetII(query_ack_raw, sizeof(query_ack_raw)),
                               std::chrono::microseconds(2000080));
        Tins::Packet response(Tins::EthernetII(response_raw, sizeof(response_raw)),
                           std::chrono::microseconds(2000100));
        Tins::Packet response_ack(Tins::EthernetII(response_ack_raw, sizeof(response_ack_raw)),
                               std::chrono::microseconds(2000120));

        THEN("Query is found and interpreted correctly")
        {
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(syn);
            pkt_stream.process_packet(pcap);
            REQUIRE(dns_msgs.size() == 0);
            pcap = std::make_shared<PcapItem>(synack);
            pkt_stream.process_packet(pcap);
            REQUIRE(dns_msgs.size() == 0);
            pcap = std::make_shared<PcapItem>(ack);
            pkt_stream.process_packet(pcap);
            REQUIRE(dns_msgs.size() == 0);
            pcap = std::make_shared<PcapItem>(query);
            pkt_stream.process_packet(pcap);
            pcap = std::make_shared<PcapItem>(query_ack);
            pkt_stream.process_packet(pcap);
            REQUIRE(dns_msgs.size() == 1);
            pcap = std::make_shared<PcapItem>(response);
            pkt_stream.process_packet(pcap);
            pcap = std::make_shared<PcapItem>(response_ack);
            pkt_stream.process_packet(pcap);
            REQUIRE(dns_msgs.size() == 2);

            std::string expected =
                "1970-01-01 00h00m02s60us UTC:\n"
                "\tClient IP: 192.168.1.77\n"
                "\tServer IP: 192.168.1.254\n"
                "\tTransport: TCP\n"
                "\tClient port: 60451\n"
                "\tServer port: 53\n"
                "\tHop limit: 64\n"
                "\tDNS QR: Query\n"
                "\tID: 19246\n"
                "\tOpcode: 0\n"
                "\tRcode: 0\n"
                "\tFlags: RD AD \n"
                "\tQdCount: 1\n"
                "\tAnCount: 0\n"
                "\tNsCount: 0\n"
                "\tArCount: 1\n"
                "\tName: www.lunch.org.uk\n"
                "\tType: 1\n"
                "\tClass: 1\n"
                "1970-01-01 00h00m02s100us UTC:\n"
                "\tClient IP: 192.168.1.77\n"
                "\tServer IP: 192.168.1.254\n"
                "\tTransport: TCP\n"
                "\tClient port: 60451\n"
                "\tServer port: 53\n"
                "\tHop limit: 64\n"
                "\tDNS QR: Response\n"
                "\tID: 19246\n"
                "\tOpcode: 0\n"
                "\tRcode: 0\n"
                "\tFlags: RD RA \n"
                "\tQdCount: 1\n"
                "\tAnCount: 2\n"
                "\tNsCount: 5\n"
                "\tArCount: 1\n"
                "\tName: www.lunch.org.uk\n"
                "\tType: 1\n"
                "\tClass: 1\n";

            std::ostringstream oss;
            oss << *(dns_msgs[0]) << *(dns_msgs[1]);
            REQUIRE(oss.str() == expected);
        }
    }

    GIVEN("A UDP query to non-DNS ports")
    {
        const uint8_t msg_raw[] =
            { 0x60,0xEB,0x69,0x8F,0x3C,0xB4,0x00,0x21,
              0x59,0x00,0xCF,0xF0,0x08,0x00,0x45,0x00,
              0x00,0x44,0xFF,0x4D,0x00,0x00,0x01,0x11,
              0x58,0xAF,0xD0,0x35,0x77,0x45,0xC7,0x07,
              0x53,0x2A,0x50,0x05,0x82,0x9B,0x00,0x30,
              0x79,0xB2,0xBE,0x6D,0x68,0x74,0x74,0x70,
              0x3A,0x2F,0x2F,0x61,0x74,0x6C,0x61,0x73,
              0x2E,0x72,0x69,0x70,0x65,0x2E,0x6E,0x65,
              0x74,0x20,0x41,0x74,0x6C,0x61,0x73,0x20,
              0x73,0x61,0x79,0x73,0x20,0x48,0x69,0x21,
              0x00,0x00 };
        Tins::Packet pkt(Tins::EthernetII(msg_raw, sizeof(msg_raw)),
                         std::chrono::microseconds(2000000));

        THEN("Packet is unhandled")
        {
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            REQUIRE_THROWS_AS(pkt_stream.process_packet(pcap),
                              unhandled_packet);
        }
    }

    GIVEN("A packet that is not IPv4 or IPv6")
    {
        const uint8_t msg_raw[] =
            { 0x60,0xEB,0x69,0x8F,0x3C,0xB4,0x00,0x21,
              0x59,0x00,0xCF,0xF0,0x04,0x00,0x25,0x00,
              0x00,0x44,0xFF,0x4D,0x00,0x00,0x01,0x11,
              0x58,0xAF,0xD0,0x35,0x77,0x45,0xC7,0x07,
              0x53,0x2A,0x50,0x05,0x00,0x35,0x00,0x30,
              0x79,0xB2,0xBE,0x6D,0x68,0x74,0x74,0x70,
              0x3A,0x2F,0x2F,0x61,0x74,0x6C,0x61,0x73,
              0x2E,0x72,0x69,0x70,0x65,0x2E,0x6E,0x65,
              0x74,0x20,0x41,0x74,0x6C,0x61,0x73,0x20,
              0x73,0x61,0x79,0x73,0x20,0x48,0x69,0x21,
              0x00,0x00 };
        Tins::Packet pkt(Tins::EthernetII(msg_raw, sizeof(msg_raw)),
                         std::chrono::microseconds(2000000));

        THEN("Packet is unhandled")
        {
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            REQUIRE_THROWS_AS(pkt_stream.process_packet(pcap),
                              unhandled_packet);
        }
    }

    GIVEN("A DNS message in non-VLAN is processed when VLAN ID set")
    {
        const uint8_t msg_raw[] =
            { 0x60,0xEB,0x69,0x8F,0x3C,0xB4,
              0x00,0x21,0x59,0x00,0xCF,0xF0,
              0x86,0xDD,
              0x60,0x00,
              0x00,0x00,0x00,0x3A,0x11,0x3B,0x20,0x01,
              0x05,0x78,0x00,0x03,0x11,0x01,0x00,0x00,
              0x00,0x00,0x00,0xBF,0x00,0x02,0x20,0x01,
              0x05,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
              0x00,0x00,0x00,0x00,0x00,0x42,0xB5,0x2A,
              0x00,0x35,0x00,0x3A,0xE7,0xEC,0x0F,0x93,
              0x00,0x10,0x00,0x01,0x00,0x00,0x00,0x00,
              0x00,0x01,0x08,0x72,0x69,0x39,0x35,0x6E,
              0x73,0x30,0x31,0x08,0x77,0x6B,0x67,0x6C,
              0x6F,0x62,0x61,0x6C,0x03,0x6E,0x65,0x74,
              0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x29,
              0x10,0x00,0x00,0x00,0x80,0x00,0x00,0x00 };
        Tins::Packet pkt(Tins::EthernetII(msg_raw, sizeof(msg_raw)),
                         std::chrono::microseconds(2000000));

        THEN("Packet is interpreted correctly")
        {
            config.vlan_ids = { 42 };
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            pkt_stream.process_packet(pcap);
            std::string expected =
                "1970-01-01 00h00m02s0us UTC:\n"
                "\tClient IP: 2001:578:3:1101::bf:2\n"
                "\tServer IP: 2001:500:3::42\n"
                "\tTransport: UDP\n"
                "\tClient port: 46378\n"
                "\tServer port: 53\n"
                "\tHop limit: 59\n"
                "\tDNS QR: Query\n"
                "\tID: 3987\n"
                "\tOpcode: 0\n"
                "\tRcode: 0\n"
                "\tFlags: CD \n"
                "\tQdCount: 1\n"
                "\tAnCount: 0\n"
                "\tNsCount: 0\n"
                "\tArCount: 1\n"
                "\tName: ri95ns01.wkglobal.net\n"
                "\tType: 1\n"
                "\tClass: 1\n";

            REQUIRE(dns_msgs.size() == 1);
            std::ostringstream oss;
            oss << *(dns_msgs[0]);
            REQUIRE(oss.str() == expected);
        }
    }

    GIVEN("A DNS message in VLAN is processed when VLAN ID set")
    {
        const uint8_t msg_raw[] =
            { 0x60,0xEB,0x69,0x8F,0x3C,0xB4,
              0x00,0x21,0x59,0x00,0xCF,0xF0,
              0x81,0x00,0x00,0x2a,
              0x86,0xDD,
              0x60,0x00,
              0x00,0x00,0x00,0x3A,0x11,0x3B,0x20,0x01,
              0x05,0x78,0x00,0x03,0x11,0x01,0x00,0x00,
              0x00,0x00,0x00,0xBF,0x00,0x02,0x20,0x01,
              0x05,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
              0x00,0x00,0x00,0x00,0x00,0x42,0xB5,0x2A,
              0x00,0x35,0x00,0x3A,0xE7,0xEC,0x0F,0x93,
              0x00,0x10,0x00,0x01,0x00,0x00,0x00,0x00,
              0x00,0x01,0x08,0x72,0x69,0x39,0x35,0x6E,
              0x73,0x30,0x31,0x08,0x77,0x6B,0x67,0x6C,
              0x6F,0x62,0x61,0x6C,0x03,0x6E,0x65,0x74,
              0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x29,
              0x10,0x00,0x00,0x00,0x80,0x00,0x00,0x00 };
        Tins::Packet pkt(Tins::EthernetII(msg_raw, sizeof(msg_raw)),
                         std::chrono::microseconds(2000000));

        THEN("Packet is interpreted correctly with correct VLAN configured")
        {
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            pkt_stream.process_packet(pcap);
            std::string expected =
                "1970-01-01 00h00m02s0us UTC:\n"
                "\tClient IP: 2001:578:3:1101::bf:2\n"
                "\tServer IP: 2001:500:3::42\n"
                "\tTransport: UDP\n"
                "\tClient port: 46378\n"
                "\tServer port: 53\n"
                "\tHop limit: 59\n"
                "\tDNS QR: Query\n"
                "\tID: 3987\n"
                "\tOpcode: 0\n"
                "\tRcode: 0\n"
                "\tFlags: CD \n"
                "\tQdCount: 1\n"
                "\tAnCount: 0\n"
                "\tNsCount: 0\n"
                "\tArCount: 1\n"
                "\tName: ri95ns01.wkglobal.net\n"
                "\tType: 1\n"
                "\tClass: 1\n";

            REQUIRE(dns_msgs.size() == 1);
            std::ostringstream oss;
            oss << *(dns_msgs[0]);
            REQUIRE(oss.str() == expected);
        }

        THEN("Packet is ignored with incorrect VLAN configured")
        {
            config.vlan_ids = { 40 };
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            pkt_stream.process_packet(pcap);
            REQUIRE(dns_msgs.size() == 0);
        }
    }

    GIVEN("An ICMP destination unreachable message")
    {
        const uint8_t msg_raw[] =
            { 0x00,0x21,0x59,0x00,0xcf,0xf0,0x60,0xeb,
              0x69,0x8f,0x3c,0xb4,0x08,0x00,0x45,0xc0,
              0x00,0x60,0xfc,0xa7,0x00,0x00,0x40,0x01,
              0x1b,0x89,0xc7,0x07,0x53,0x2a,0xd0,0x35,
              0x77,0x45,0x03,0x03,0x5e,0xeb,0x00,0x00,
              0x00,0x00,0x45,0x00,0x00,0x44,0xff,0x4d,
              0x00,0x00,0x01,0x11,0x58,0xaf,0xd0,0x35,
              0x77,0x45,0xc7,0x07,0x53,0x2a,0x50,0x05,
              0x82,0x9b,0x00,0x30,0x79,0xb2,0xbe,0x6d,
              0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x61,
              0x74,0x6c,0x61,0x73,0x2e,0x72,0x69,0x70,
              0x65,0x2e,0x6e,0x65,0x74,0x20,0x41,0x74,
              0x6c,0x61,0x73,0x20,0x73,0x61,0x79,0x73,
              0x20,0x48,0x69,0x21,0x00,0x00 };
        Tins::Packet pkt(Tins::EthernetII(msg_raw, sizeof(msg_raw)),
                         std::chrono::microseconds(2000000));

        THEN("ICMP event is interpreted correctly")
        {
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            pkt_stream.process_packet(pcap);
            REQUIRE(addr_events.size() == 1);
            REQUIRE(addr_events[0]->type() == AddressEvent::ICMP_DEST_UNREACHABLE);
            REQUIRE(addr_events[0]->code() == 3);
            std::ostringstream oss;
            oss << addr_events[0]->address();
            REQUIRE(oss.str() == "199.7.83.42");
        }
    }

    GIVEN("An ICMP destination unreachable message with malformed TCP inner content")
    {
        const uint8_t msg_raw[] =
            { 0x00,0x21,0x59,0x00,0xcf,0xf0,0x60,0xeb,
              0x69,0x8f,0x3c,0xb4,0x08,0x00,0x45,0xc0,
              0x00,0x60,0xfc,0xa7,0x00,0x00,0x40,0x01,
              0x1b,0x89,0xc7,0x07,0x53,0x2a,0xd0,0x35,
              0x77,0x45,0x03,0x03,0x5e,0xeb,0x00,0x00,
              0x00,0x00,0x45,0x00,0x00,0x44,0xff,0x4d,
              0x00,0x00,0x01,0x06,0x58,0xaf,0xd0,0x35,
              0x77,0x45,0xc7,0x07,0x53,0x2a,0x50,0x05,
              0x82,0x9b,0x00,0x30,0x79,0xb2,0xbe,0x6d,
              0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x61,
              0x74,0x6c,0x61,0x73,0x2e,0x72,0x69,0x70,
              0x65,0x2e,0x6e,0x65,0x74,0x20,0x41,0x74,
              0x6c,0x61,0x73,0x20,0x73,0x61,0x79,0x73,
              0x20,0x48,0x69,0x21,0x00,0x00 };
        Tins::Packet pkt(Tins::EthernetII(msg_raw, sizeof(msg_raw)),
                         std::chrono::microseconds(2000000));

        THEN("ICMP event is interpreted correctly")
        {
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            pkt_stream.process_packet(pcap);
            REQUIRE(addr_events.size() == 1);
            REQUIRE(addr_events[0]->type() == AddressEvent::ICMP_DEST_UNREACHABLE);
            REQUIRE(addr_events[0]->code() == 3);
            std::ostringstream oss;
            oss << addr_events[0]->address();
            REQUIRE(oss.str() == "199.7.83.42");
        }
    }

    GIVEN("An ICMPv6 destination unreachable message")
    {
        const uint8_t msg_raw[] =
            { 0x60,0xeb,0x69,0x8f,0x3c,0xb4,0x00,0x21,
              0x59,0x00,0xcf,0xf0,0x86,0xdd,0x60,0x00,
              0x00,0x00,0x01,0xfe,0x3a,0x36,0x20,0x01,
              0x05,0xb0,0x2a,0xff,0xff,0xf7,0x00,0x00,
              0x00,0x00,0x00,0x00,0x00,0x05,0x20,0x01,
              0x05,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
              0x00,0x00,0x00,0x00,0x00,0x42,0x01,0x01,
              0x15,0xab,0x00,0x00,0x00,0x00,0x60,0x00,
              0x00,0x00,0x01,0xce,0x11,0x39,0x20,0x01,
              0x05,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
              0x00,0x00,0x00,0x00,0x00,0x42,0x20,0x01,
              0x05,0xb0,0x2a,0xff,0xff,0xf7,0x00,0x00,
              0x00,0x00,0x00,0x00,0x00,0x05,0x00,0x35,
              0x41,0x7f,0x01,0xce,0xd9,0xcb,0xa9,0x46,
              0x84,0x03,0x00,0x01,0x00,0x00,0x00,0x04,
              0x00,0x01,0x01,0x34,0x03,0x31,0x33,0x30,
              0x03,0x31,0x38,0x30,0x00,0x00,0x01,0x00,
              0x01,0x00,0x00,0x06,0x00,0x01,0x00,0x01,
              0x51,0x80,0x00,0x40,0x01,0x61,0x0c,0x72,
              0x6f,0x6f,0x74,0x2d,0x73,0x65,0x72,0x76,
              0x65,0x72,0x73,0x03,0x6e,0x65,0x74,0x00,
              0x05,0x6e,0x73,0x74,0x6c,0x64,0x0c,0x76,
              0x65,0x72,0x69,0x73,0x69,0x67,0x6e,0x2d,
              0x67,0x72,0x73,0x03,0x63,0x6f,0x6d,0x00,
              0x78,0x2a,0x56,0x35,0x00,0x00,0x07,0x08,
              0x00,0x00,0x03,0x84,0x00,0x09,0x3a,0x80,
              0x00,0x01,0x51,0x80,0x00,0x00,0x2f,0x00,
              0x01,0x00,0x01,0x51,0x80,0x00,0x0e,0x03,
              0x61,0x61,0x61,0x00,0x00,0x07,0x22,0x00,
              0x00,0x00,0x00,0x03,0x80,0x00,0x00,0x2e,
              0x00,0x01,0x00,0x01,0x51,0x80,0x00,0x93,
              0x00,0x06,0x08,0x00,0x00,0x01,0x51,0x80,
              0x57,0x11,0x1e,0x10,0x57,0x03,0xe1,0x00,
              0xec,0xc7,0x00,0x17,0x59,0x67,0x28,0x6e,
              0xa0,0x1d,0x5d,0x4b,0x17,0x98,0x4e,0x4c,
              0xff,0xc5,0xf1,0x27,0xbd,0x4b,0x1f,0xe2,
              0xa6,0xe0,0x37,0x09,0x64,0x60,0x1b,0xb4,
              0x82,0x19,0xc7,0x65,0xb0,0x7a,0x73,0xa9,
              0x4b,0xc7,0xae,0xcb,0xb5,0xa5,0x10,0x9f,
              0x6f,0x54,0xa6,0xa2,0xf2,0x2b,0xff,0x94,
              0x10,0x76,0xd4,0x90,0x76,0x43,0x71,0x3b,
              0x1f,0xe0,0xb5,0x67,0x29,0xee,0x03,0xae,
              0x99,0x6a,0x50,0xab,0x7c,0xa2,0xba,0xa7,
              0x6c,0x42,0x8c,0xf4,0x61,0xaa,0x7f,0xaa,
              0xfc,0x7c,0x8b,0xf6,0x96,0xa6,0xd0,0xbf,
              0x0f,0x40,0xfa,0xd9,0xc3,0x06,0x27,0xf6,
              0x47,0xcc,0xf8,0x8f,0x47,0x79,0x2c,0x95,
              0x62,0x91,0xcb,0x66,0x4a,0xdc,0xf0,0xb4,
              0x08,0xda,0xab,0x4c,0xc2,0x3e,0xf1,0x55,
              0x5e,0x48,0x1c,0x00,0x00,0x2e,0x00,0x01,
              0x00,0x01,0x51,0x80,0x00,0x93,0x00,0x2f,
              0x08,0x00,0x00,0x01,0x51,0x80,0x57,0x11,
              0x1e,0x10,0x57,0x03,0xe1,0x00,0xec,0xc7,
              0x00,0x83,0x0a,0x7e,0xce,0x23,0xa7,0xb8,
              0x4c,0x70,0xed,0xaa,0xfd,0x7b,0x83,0xa2,
              0xba,0xf3,0x64,0xed,0xd9,0x11,0xbb,0x5a,
              0x73,0x1c,0x3e,0x59,0x70,0x45,0x10,0xe3,
              0x9f,0xa2,0x2a,0xd4,0xd8,0xf6,0x95,0x76,
              0x14,0x69,0x46,0xc4,0x40,0x30,0x41,0xd8,
              0xbb,0x19,0x8e,0x8a,0xab,0xe5,0x05,0xfb,
              0xa7,0xb5,0x5d,0x3e,0x4e,0xcc,0x82,0x93,
              0x83,0xa8,0xfc,0x16,0xbd,0x18,0x36,0xcb,
              0xba,0xc5,0x9b,0xd1,0x30,0x93,0x29,0x80,
              0x70,0x35,0x1b,0x16,0xcb,0x57,0xd7,0xae,
              0x5e,0x7a,0x50,0x9f,0x61,0xe7,0xf3,0x15,
              0x21,0x0e,0xb2,0x56,0xda,0xf1,0x5c,0x78,
              0x50,0x78,0x8a,0x9b,0x27,0x4a,0x59,0x20,
              0x9a,0x8f,0x87,0x67,0xce,0x99,0xe3,0xea,
              0x4c,0xda,0x68,0x0d,0x26,0xfc,0xe8,0xef,
              0xa4,0x00,0x00,0x29,0x10,0x00,0x00,0x00,
              0x80,0x00,0x00,0x00 };
        Tins::Packet pkt(Tins::EthernetII(msg_raw, sizeof(msg_raw)),
                         std::chrono::microseconds(2000000));

        THEN("ICMPv6 event is interpreted correctly")
        {
            std::shared_ptr<PcapItem> pcap = std::make_shared<PcapItem>(pkt);
            pkt_stream.process_packet(pcap);
            REQUIRE(addr_events.size() == 1);
            REQUIRE(addr_events[0]->type() == AddressEvent::ICMPv6_DEST_UNREACHABLE);
            REQUIRE(addr_events[0]->code() == 1);
            std::ostringstream oss;
            oss << addr_events[0]->address();
            REQUIRE(oss.str() == "2001:5b0:2aff:fff7::5");
        }
    }
}
